数字证书
===
数字证书是一个经证书授权中心数字签名的包含公开密钥拥有者信息以及公开密钥的文件，确保网络通讯的安全。
###（一）基本概念
**加密**：对数据进行处理变成不可读的一段代码，以保护数据不被人窃取，加密分为对称加密和非对称加密。  
**对称加密**：加密和解密密钥相同，速度快效率高，如 DES。  
**非对称加密**：加密和解密密钥不同，分公开密钥和私有密钥，公密发给其他人，私钥自己保存，由公钥加密的数据能且只能由私钥解密，由私钥加密的数据能且只能由公钥解密，安全性强，如 RSA。  
**签名**：在信息后面加上一段内容，证明信息没有被修改，一般是对信息hash得出hash值，作为签名附带在信息后一起发给接收者，接收者拿到数据，同样对信息进行hash得出hash值，跟附带的签名hash做匹配。

###（二）加密通信演化
####（1）直接传输
    客户端-》服务器：你好  
    服务器-》客户端：我是服务器

黑客可以在传输过程中如路由端窃取信息并伪装成服务器，跟客户端通信。
  
    客户端-》服务器：你好  
    服务器未收到，被黑客拦截  
    黑客-》客户端：我是黑客

####（2）RSA加密
解决辨认是否服务器的问题，服务器采用 RSA 加密方式返回数据。  

    客户端-》服务器：你好  
    服务器-》客户端：{我是服务器}[私钥|RSA]  //前面是加密后数据，后面是[加密密钥|加密算法]  

客户端收到信息后，用RSA公钥对{我是服务器}进行解密获取到"我是服务器"。

####（3）客户端增加对称密钥加密
简单地使用RSA不能确保通信信息安全，其他拥有公钥的客户端也能获取到服务器发过来的信息，如下面的情况  

    客户端-》服务器：你好  
    服务器-》客户端：{我是服务器}[私钥|RSA]  
    客户端-》服务器：{给我看看余额多少}[公钥|RSA]  
    服务器-》客户端：{你的余额是100元}[私钥|RSA]  
另一个客户端1接收到{你的余额是100元}，利用自己的公钥1对{你的余额是100元}进行解密一样可以获取到"你的余额是100元"。

改进版如下，客户端会要求服务器采用自己的加密算法，对服务器传输的信息进行加密。

    客户端-》服务器：你好  
    服务器-》客户端：{我是服务器}[私钥|RSA]   
    客户端-》服务器：{我们后面的数据传输加密，用xxx对称加密算法，密钥是yyy}[公钥|RSA]  
    服务器-》客户端：{好的！}[私钥|RSA]  
    客户端-》服务器：{给我看看余额多少}[密钥|给的对称加密算法]  
    服务器-》客户端：{你的余额是100元}[密钥|给的对称加密算法]  
客户端发送的加密算法和密钥，用公钥RSA加密，只有服务器私钥才能解析，所以是安全的，后续的信息传输都用新的未知的加密算法，所以整个流程是安全的。

####（4）解决公钥发布问题
公钥并非完全是安全的，可能存在下载错误的公钥，或者存储的公钥被替换的情况。

    客户端存储的公钥被人替换成新的公钥1
    客户端-》服务器：你好  
    黑客-》客户端：{我是服务器}[私钥1|RSA]   
    客户端-》黑客：{我们后面的数据传输加密，用xxx对称加密算法，密钥是yyy}[公钥1|RSA]  
    黑客-》客户端：{好的！}[私钥1|RSA]
    
为了解决公钥是否从属于指定公司，出现了"证书中心"，指定公司需要从国际证书中心申请私钥，"证书中心"在数字证书中加入指定公司、公钥等信息。  

    客户端-》服务器：你好  
    服务器-》客户端：这是你要的数字证书
    客户端-》服务器：收到 
    客户端根据数字证书获取到请求的公钥
    客户端-》服务器：你好
    服务器-》客户端：{我是服务器}[私钥|RSA]   
    客户端-》服务器：{我们后面的数据传输加密，用xxx对称加密算法，密钥是yyy}[公钥|RSA]  
    服务器-》客户端：{好的！}[私钥|RSA]  

在 windows 中默认按照了国际证书中心的证书，在获取到数字证书的时候可以做验证，是否证书确实是国际证书中心发布的。
https 就是数字证书的一个应用案例，用抓包工具可以看到request和response的信息都是乱码。